import fs from 'fs/promises';
import path from 'path';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { ProviderManager } from './ProviderManager.js';

interface Tool {
  name: string;
  description?: string;
  inputSchema?: {
    type?: string;
    properties?: Record<string, any>;
    required?: string[];
  };
}

export class ToolDocumenter {
  // We'll try to resolve to the project root.
  private static get STORAGE_PATH() {
    let root = process.cwd();
    if (root.endsWith('apps/api')) {
        root = path.resolve(root, '../../');
    }
    const p = path.resolve(root, '.domoreai/tools');
    console.log('[ToolDocumenter] Storage Path:', p);
    return p;
  }

  static async documentServer(serverName: string, client: Client) {
    try {
      const result = await client.listTools();
      const tools = result.tools as Tool[];
      await this.documentTools(serverName, tools);
    } catch (error) {
      console.error(`[ToolDocumenter] Failed to document server ${serverName}:`, error);
    }
  }

  static async documentTools(sourceName: string, tools: Tool[]) {
    try {
      // Ensure directory exists
      await fs.mkdir(this.STORAGE_PATH, { recursive: true });
      
      if (!tools || tools.length === 0) return;

      // 1. Generate Type Definitions
      const typeDefs = this.generateTypeDefinitions(sourceName, tools);
      await fs.writeFile(path.join(this.STORAGE_PATH, `${sourceName}.d.ts`), typeDefs);

      // 2. Generate Comprehensive Documentation
      const documentation = await this.generateDocumentation(sourceName, tools);
      await fs.writeFile(path.join(this.STORAGE_PATH, `${sourceName}_examples.md`), documentation);
      
      console.log(`[ToolDocumenter] Generated documentation for ${sourceName}`);
    } catch (error) {
      console.error(`[ToolDocumenter] Failed to document tools for ${sourceName}:`, error);
    }
  }

  private static generateTypeDefinitions(serverName: string, tools: Tool[]): string {
    const lines: string[] = [];
    
    lines.push(`// Type definitions for ${serverName}`);
    lines.push(`// Generated by ToolDocumenter`);
    lines.push('');
    lines.push('declare namespace system {');

    for (const tool of tools) {
      const toolName = `${serverName}_${tool.name}`;
      const interfaceName = `${this.capitalize(serverName)}${this.capitalize(tool.name)}Args`;
      
      // Generate Interface from JSON Schema
      const schema = tool.inputSchema;
      const props: string[] = [];
      
      if (schema && schema.properties) {
        for (const [key, value] of Object.entries(schema.properties)) {
          // Cast value to any or check type
          if (typeof value === 'object' && value !== null && 'type' in (value)) {
            const isOptional = !schema.required?.includes(key);
            const type = this.mapJsonTypeToTs((value).type);
            props.push(`    /** ${(value).description || ''} */`);
            props.push(`    ${key}${isOptional ? '?' : ''}: ${type};`);
          }
        }
      }

      lines.push(`  interface ${interfaceName} {`);
      lines.push(props.join('\n'));
      lines.push(`  }`);
      lines.push('');
      lines.push(`  /**`);
      lines.push(`   * ${tool.description || 'No description provided.'}`);
      lines.push(`   */`);
      lines.push(`  function ${toolName}(args: ${interfaceName}): Promise<any>;`);
      lines.push('');
    }

    lines.push('}');
    return lines.join('\n');
  }

  private static async generateDocumentation(serverName: string, tools: Tool[]): Promise<string> {
    const docs: string[] = [];

    // [NEW] Strategic Selection
    // Documentation is a "Heavy Context" task. We need big windows.
    let model = null;
    try {
        const allModels = await ProviderManager.getAllModels();
        
        // 1. Filter for models with > 32k context
        // 2. Sort by Cost (Free first) -> Then by Context Size (Descending)
        const capableModels = allModels
            .filter(m => ((m.specs?.contextWindow || 0) >= 32000))
            .sort((a, b) => {
                // Primary Sort: Cost (Ascending) - prioritize Free
                if ((a.costPer1k || 0) !== (b.costPer1k || 0)) return (a.costPer1k || 0) - (b.costPer1k || 0);
                // Secondary Sort: Context (Descending) - get the biggest window available for that price
                return ((b.specs?.contextWindow || 0) - (a.specs?.contextWindow || 0));
            });

        model = capableModels[0] || allModels[0];

        if (model) {
            console.log(`üìö Tool Documenter using: ${model.id} (Context: ${model.specs?.contextWindow || 'unknown'})`);
        } else {
            console.warn("‚ö†Ô∏è No suitable model found for Tool Documentation. Defaulting to system fallback.");
        }
    } catch (e) {
        console.warn('[ToolDocumenter] Failed to load models for smart documentation:', e);
    }

    for (const tool of tools) {
      const toolName = serverName === 'system' ? tool.name : `${serverName}_${tool.name}`;
      const interfaceName = `${this.capitalize(serverName)}${this.capitalize(tool.name)}Args`;
      
      docs.push(`### Tool: \`system.${toolName}\``);
      docs.push(`**Description:** ${tool.description || 'No description provided.'}`);
      docs.push('');
      
      // Signature
      docs.push('**Signature:**');
      docs.push('```typescript');
      docs.push(`await system.${toolName}(args: ${interfaceName})`);
      docs.push('```');
      docs.push('');

      // Arguments Table
      docs.push('**Arguments:**');
      docs.push('| Name | Type | Required | Description |');
      docs.push('|------|------|----------|-------------|');
      
      const schema = tool.inputSchema;
      if (schema && schema.properties) {
        for (const [key, value] of Object.entries(schema.properties)) {
           const v = value;
           const type = this.mapJsonTypeToTs(v.type);
           const required = schema.required?.includes(key) ? 'Yes' : 'No';
           const desc = (v.description || '').replace(/\n/g, ' ');
           docs.push(`| \`${key}\` | \`${type}\` | ${required} | ${desc} |`);
        }
      } else {
        docs.push('| - | - | - | No arguments |');
      }
      docs.push('');

      // Usage Example
      docs.push('**Usage Example:**');
      docs.push('```typescript');
      
      let exampleCode = `// Call ${toolName}\nawait system.${toolName}({ /* args */ });`;

      if (model) {
        try {
            const provider = ProviderManager.getProvider(model.providerId || '');
            if (provider) {
                const prompt = `
                You are an expert TypeScript developer.
                I have a tool named "system.${toolName}".
                Description: ${tool.description}
                Input Schema: ${JSON.stringify(tool.inputSchema)}

                Write a realistic, executable TypeScript code block showing how to use this tool in a "Code Mode" environment.
                - Use top-level await or an async function.
                - Include comments explaining the step.
                - Do NOT wrap in markdown code blocks (I will add them).
                - Keep it concise (3-5 lines).
                `;

                const response = await provider.generateCompletion({
                    modelId: model.id,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.2,
                    max_tokens: 200
                });
                
                exampleCode = response.trim().replace(/^```typescript\n|^```ts\n|^```/g, '').replace(/```$/g, '');
            }
        } catch (e) {
            console.warn(`[ToolDocumenter] Failed to generate smart example for ${toolName}`, e);
        }
      }

      docs.push(exampleCode);
      docs.push('```');
      docs.push('');
      docs.push('---');
      docs.push('');
    }

    return docs.join('\n');
  }

  private static capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  private static mapJsonTypeToTs(type: string): string {
    switch (type) {
      case 'string': return 'string';
      case 'integer': return 'number';
      case 'number': return 'number';
      case 'boolean': return 'boolean';
      case 'array': return 'any[]';
      case 'object': return 'any';
      default: return 'any';
    }
  }
}
