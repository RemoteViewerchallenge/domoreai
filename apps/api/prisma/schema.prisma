datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -----------------------------------------------------------------
// Stores the provider-specific credentials and configuration
// -----------------------------------------------------------------
model ProviderConfig {
  id          String   @id @default(uuid())
  label       String
  type        String
  apiKey      String   // Encrypted
  baseURL     String?
  isEnabled   Boolean  @default(true)
  requestsPerMinute Int? @default(60)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  models      Model[]
  

}

// -----------------------------------------------------------------
// Stores the individual models from all providers
// -----------------------------------------------------------------
// THE FLEXIBLE CORE
model Model {
  id        String @id @default(cuid())
  
  providerId String @map("provider_id")
  provider   ProviderConfig @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // Strict Identity
  modelId      String  @map("model_id")
  name         String  @map("model_name")

  // [NEW] Layer 3: The Specialized Capabilities Table
  capabilities ModelCapabilities?

  // [UPDATED] Layer 1: Raw Data Lake (Keep this! It's your backup)
  providerData Json    @default("{}") @map("provider_data")
  
  // [UPDATED] Layer 2: AI Knowledge (Inferred/Researched)
  aiData       Json    @default("{}") @map("ai_data")

  // [DEPRECATED] Specs will be replaced by ModelCapabilities
  specs        Json    @default("{}") @map("specs")

  // Fast filtering for Orchestrator tokens
  capabilityTags String[] @default(["text"]) @map("capability_tags")

  isFree       Boolean @default(false) @map("is_free")
  costPer1k    Float?  @map("cost_per_1k")

  isActive     Boolean @default(true) @map("is_active")
  source       ModelSource @default(INDEX)
  
  firstSeenAt  DateTime @default(now()) @map("first_seen_at")
  lastSeenAt   DateTime @default(now()) @map("last_seen_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  modelUsage   ModelUsage[]
  knowledgeVectors KnowledgeVector[]
  
  @@unique([providerId, modelId])
  @@index([providerId, lastSeenAt])
  @@map("model_registry")
}

// [NEW] The Related Table for gathered/aligned data
model ModelCapabilities {
  id          String   @id @default(cuid())
  modelId     String   @unique
  model       Model    @relation(fields: [modelId], references: [id], onDelete: Cascade)

  // Context & Throughput
  contextWindow Int?     @default(4096) // Fail-Open default
  maxOutput     Int?     @default(4096)
  
  // Features (Booleans for fast filtering)
  hasVision         Boolean @default(false)
  hasAudioInput     Boolean @default(false)
  hasAudioOutput    Boolean @default(false)
  hasTTS            Boolean @default(false)
  hasImageGen       Boolean @default(false)
  isMultimodal      Boolean @default(false)
  supportsFunctionCalling Boolean @default(false)
  supportsJsonMode  Boolean @default(false)

  // Technical Specs
  tokenizer         String? // e.g., "cl100k_base"
  paramCount        String? // e.g., "70B"
  
  // Rate Limits
  requestsPerMinute Int?
  tokensPerMinute   Int?

  updatedAt   DateTime @updatedAt
}

// Enum for tracking model discovery source
enum ModelSource {
  INDEX      // Found in provider's official list
  INFERENCE  // Discovered during successful runtime usage
  MANUAL     // Manually added by user
}

// Persisted model failure counts to avoid retrying known-broken models across restarts
model ModelFailure {
  id         String   @id @default(cuid())
  providerId String
  modelId    String
  // Optional role scope so failures are specific to a role
  roleId     String?
  failures   Int      @default(0)
  lastFailedAt DateTime @updatedAt
  createdAt  DateTime @default(now())

  // Unique per provider+model+role (role may be null)
  @@unique([providerId, modelId, roleId])
}

model ProviderFailure {
  id         String   @id @default(cuid())
  providerId String
  // Optional role scope so provider failures can be tracked per role
  roleId     String?
  failures   Int      @default(0)
  lastFailedAt DateTime @updatedAt
  createdAt  DateTime @default(now())

  @@unique([providerId, roleId])
}

// -----------------------------------------------------------------
// Stores the Roles for your agents
// -----------------------------------------------------------------
model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?  @db.Text
  basePrompt  String   @db.Text
  tools       String[] @default([]) // Array of tool names
  categoryString String? @map("category")
  
  // Relations
  categoryId  String?
  category    RoleCategory? @relation(fields: [categoryId], references: [id])
  
  // Role Parameters
  // No hyperparameters on Role anymore - managed by metadata or defaults
  metadata    Json?    @default("{}")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  modelUsage  ModelUsage[]
  jobs        Job[]
}

model RoleCategory {
  id        String   @id @default(cuid())
  name      String   @unique
  order     Int      @default(0)
  
  parentId  String?
  parent    RoleCategory? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children  RoleCategory[] @relation("CategoryHierarchy")

  roles     Role[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}





// -----------------------------------------------------------------
// Stores the usage logs for models
// -----------------------------------------------------------------
model ModelUsage {
  id             String    @id @default(cuid())
  createdAt      DateTime  @default(now())
  userId         String
  modelId        String
  roleId         String
  // Usage Metrics
  promptTokens     Int?
  completionTokens Int?
  cost             Float
  
  // [NEW] Universal Meter
  // Stores non-token usage metrics found in headers or calculated by the agent.
  // e.g. { "images_processed": 2, "audio_seconds": 45, "vector_dimensions": 1536 }
  usageMetrics     Json?     @default("{}") @map("usage_metrics")
  
  // [CHANGE] explicitly document that this JSON contains the raw headers
  // e.g. { "x-ratelimit-remaining": "50", "x-ratelimit-reset": "16999999" }
  responseHeaders  Json?     @map("response_headers") 

  // General metadata (errors, finish_reason, etc.)
  metadata         Json?

  // Relations
  model          Model       @relation(fields: [modelId], references: [id])
  role           Role        @relation(fields: [roleId], references: [id])
}

// -----------------------------------------------------------------
// Raw Data Lake
// Stores raw API responses before they are processed into Models
// This is the "Bag" that prevents data loss from provider API glitches
// -----------------------------------------------------------------
model RawDataLake {
  id         String   @id @default(cuid())
  provider   String   // e.g. "google", "openrouter", "groq"
  fileName   String?  // e.g. "google_models_2025-12-06T07-15-03.json"
  rawData    Json     // The exact JSON returned by the provider's list models endpoint
  ingestedAt DateTime @default(now())
  processed  Boolean  @default(false) // Track if this has been normalized into Model table
  
  @@index([provider, processed])
  @@index([ingestedAt])
}

model FlattenedTable {
  id          String   @id @default(cuid())
  name        String   @unique // Table name in Postgres
  sourceId    String   // RawDataLake record ID
  columns     Json     // Column definitions {name: string, type: string}[]
  rowCount    Int      @default(0)
  createdAt   DateTime @default(now())
}

// -----------------------------------------------------------------
// Stores how a Raw Table maps to the Unified Model Schema
// Used by the "Merge to C.O.R.E." feature
// -----------------------------------------------------------------
model TableMapping {
  id        String   @id @default(cuid())
  tableName String   @unique // e.g., "openrouterfree"
  
  // Stores the mapping: { "raw_column_name": "Model_field_name" }
  // e.g., { "context_length": "contextWindow", "pricing": "costPer1k" }
  mapping   Json     
  
  updatedAt DateTime @updatedAt
}

model OrchestratorConfig {
  id             String   @id @default("global")
  activeTableName String  @default("model_registry") // The user-selected table
  
  // Future-proofing for strategies
  strategies     Json?    @default("[]") 
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

// Stores reusable SQL queries for data refinement and migration
model SavedQuery {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "OpenRouter Free Models Migration"
  query       String   @db.Text
  targetTable String?  // The table this query targets (e.g., "my_free_models")
  updatedAt   DateTime @updatedAt
}

// Represents a broad scope of work (e.g., a specific repository or project)
model Workspace {
  id        String   @id @default(cuid())
  name      String
  rootPath  String   // Local path on the host machine
  systemPrompt String? @db.Text
  
  // Constitution: Global Rules for Agents
  codeRules String?  @db.Text // Code style rules and conventions (e.g., "Always use FlyonUI", "No Git Diffs - Use Branches")
  glossary  Json?    @default("{}") // Key-value pairs for project-specific terminology (e.g., {"SuperNode": "A file visualizer"})
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  cards     WorkOrderCard[]
}

// Formerly "Session" or generic "Context" - The persisted state of a user's task
model WorkOrderCard {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  
  // Fencing Configuration
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  relativePath String   @default(".") // Path relative to Workspace root
  
  // [NEW] Context Intelligence
  // We store the calculated "weight" of this card's scope here.
  // Agents populate this. If null, it means "needs analysis."
  contextStats   Json? 
  // Example data shape:
  // { 
  //   "fileSize": 10240, 
  //   "estimatedTokens": 2500, 
  //   "fileCount": 5, 
  //   "lastAnalyzedAt": "2023-10-27T10:00:00Z" 
  // }

  // Execution Context
  isRemote    Boolean  @default(false)
  sshConfigId String?  // Optional relation to saved SSH configs (if we persist them)

  // NEW: System Prompt specific to this card
  systemPrompt String? @db.Text

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Securely store SSH configs (excluding sensitive secrets if possible, or encrypted)
model SshConfig {
  id        String   @id @default(cuid())
  alias     String   // e.g., "Production Server"
  host      String
  port      Int      @default(22)
  username  String
  // Note: Passwords/Keys should generally be session-based or encrypted via `utils/encryption.ts`
  createdAt DateTime @default(now())
}

// -----------------------------------------------------------------
// Project Management Hierarchy
// -----------------------------------------------------------------

// Top-level container for a complete scope of work.
model Project {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed", "on_hold"
  priority    String   @default("medium") // e.g., "low", "medium", "high", "critical"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relation to its jobs
  jobs        Job[]
}

// A significant phase or step within a project, assigned to a Role.
model Job {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed", "failed"
  priority    String   @default("medium")

  // --- Relations ---
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  roleId      String?  // The role responsible for this job
  role        Role?    @relation(fields: [roleId], references: [id])

  // [NEW] Hierarchy for "Cell Division"
  // Allows a "Lead" job to own several "Worker" jobs
  parentJobId    String?
  parentJob      Job?      @relation("JobHierarchy", fields: [parentJobId], references: [id])
  childJobs      Job[]     @relation("JobHierarchy")

  // --- Execution Flow ---
  // For sequential jobs, this points to the job that must be completed first.
  dependsOnJobId String?  @unique
  dependsOn      Job?     @relation("JobDependencies", fields: [dependsOnJobId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  dependencyFor  Job?     @relation("JobDependencies")

  // For parallel jobs, this groups them. They can start once the job they depend on is complete.
  parallelGroup String?

  // --- Timing ---
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relation to its tasks
  tasks       Task[]

  @@index([projectId, status])
  @@index([roleId])
}

// A granular piece of work within a job.
model Task {
  id          String   @id @default(cuid())
  description String   @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed"

  // --- Relations ---
  jobId       String
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  // --- Timing & Data ---
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?
  completionData Json? // Any data/output generated by the task
  
  // Relation to its errands
  errands     Errand[]
}

// The most granular action, like a single command or API call.
model Errand {
  id          String   @id @default(cuid())
  description String   @db.Text
  status      String   @default("not_started") // e.g., "not_started", "completed"

  // --- Relations ---
  taskId      String
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // --- Timing ---
  createdAt   DateTime @default(now())
  completedAt DateTime?
}


// -----------------------------------------------------------------
// Orchestration: Defines workflows between roles
// -----------------------------------------------------------------
model Orchestration {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?  @db.Text
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // User ID who created this orchestration
  
  // Steps in this orchestration (ordered)
  steps       OrchestrationStep[]
  
  // [NEW] Sub-Orchestration Support (Reverse Relation)
  // Steps that use this orchestration as a sub-orchestration
  usedBySteps OrchestrationStep[] @relation("SubOrchestrations")
  
  // Execution history
  executions  OrchestrationExecution[]
  
  // Tags for categorization
  tags        String[] @default([])
  
  // Enable/disable this orchestration
  isActive    Boolean  @default(true)
}

// -----------------------------------------------------------------
// OrchestrationStep: Individual step in an orchestration
// -----------------------------------------------------------------
model OrchestrationStep {
  id              String   @id @default(cuid())
  
  // Relation to parent orchestration
  orchestrationId String
  orchestration   Orchestration @relation(fields: [orchestrationId], references: [id], onDelete: Cascade)
  
  // Step metadata
  name            String   // e.g., "Generate Plan", "Execute Code Review"
  description     String?  @db.Text
  order           Int      // Execution order (0, 1, 2, ...)
  
  // Role assignment
  // Role assignment removed to decouple Roles from Orchestrations
  // roleId          String?
  // roleName        String?
  
  // Control flow
  stepType        String   @default("sequential") // "sequential", "parallel", "conditional", "loop", "sub_orchestration"
  
  // [NEW] Sub-Orchestration Support (Russian Doll Nesting)
  // When stepType is "sub_orchestration", this points to another Orchestration to execute
  subOrchestrationId String?
  subOrchestration   Orchestration? @relation("SubOrchestrations", fields: [subOrchestrationId], references: [id], onDelete: SetNull)
  
  // [NEW] Confidence & Quality Control
  // Minimum confidence score required for this step's output (0.0 - 1.0)
  minConfidence   Float?   @default(0.8)
  // Actual confidence score from the last execution (populated by ConfidenceAgent)
  lastConfidence  Float?
  
  // [NEW] Corporate Tier / Rank for Model Selection
  // "Executive" = expensive, powerful models (o1-preview, claude-opus)
  // "Manager" = mid-tier models (gpt-4o, claude-sonnet)
  // "Worker" = cheap, fast models (gpt-4o-mini, gemini-flash)
  tier            String?  @default("Worker") // "Executive", "Manager", "Worker"
  
  // Conditional logic (JSON schema)
  condition       Json?    // e.g., { "field": "output.confidence", "operator": ">", "value": 0.8 }
  
  // Input/Output mapping
  inputMapping    Json?    // Maps orchestration context to step input, e.g., { "query": "{{context.userQuery}}" }
  outputMapping   Json?    // Maps step output to orchestration context, e.g., { "plan": "{{output.result}}" }
  
  // Retry configuration
  maxRetries      Int      @default(0)
  retryDelay      Int?     // Delay in milliseconds between retries
  
  // Timeout
  timeout         Int?     // Timeout in milliseconds
  
  // Parallel execution group (for parallel steps)
  parallelGroup   String?  // Steps with same group ID execute in parallel
  
  // Validation and context access controls (Anubis guards additions)
  validationRules Json?    // Optional JSON validation rules/guards for this step
  contextKeys     String[] @default([]) // Keys of memory/context this step is allowed to access
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([orchestrationId, order])
}

// -----------------------------------------------------------------
// OrchestrationExecution: Tracks execution of orchestrations
// -----------------------------------------------------------------
model OrchestrationExecution {
  id              String   @id @default(cuid())
  
  // Relation to orchestration
  orchestrationId String
  orchestration   Orchestration @relation(fields: [orchestrationId], references: [id], onDelete: Cascade)
  
  // Execution metadata
  status          String   @default("pending") // "pending", "running", "completed", "failed", "cancelled"
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  // Input and output
  input           Json     // Initial input to the orchestration
  output          Json?    // Final output
  context         Json     @default("{}") // Shared context across steps
  
  // Step execution logs
  stepLogs        Json     @default("[]") // Array of { stepId, status, input, output, duration, error }
  
  // Error tracking
  error           String?  @db.Text
  
  // User who triggered this execution
  userId          String?
  
  @@index([orchestrationId, status])
  @@index([startedAt])
}

// -----------------------------------------------------------------
// Agent Lessons: Learned behaviors and rules
// -----------------------------------------------------------------
model AgentLesson {
  id          String   @id @default(cuid())
  trigger     String   // Keyword or phrase that triggers this lesson
  rule        String   // The instruction/rule to follow
  confidence  Float    @default(1.0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// -----------------------------------------------------------------
// UI Configuration Models
// -----------------------------------------------------------------

model CardConfig {
  cardId      String   @id
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  customButtons CustomButton[]
  componentRoles ComponentRole[]
}

model CustomButton {
  id          String   @id @default(cuid())
  cardId      String
  cardConfig  CardConfig @relation(fields: [cardId], references: [cardId], onDelete: Cascade)
  
  label       String
  action      String   // 'command', 'url', 'agent'
  actionData  String
  icon        String?
  color       String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ComponentRole {
  id          String   @id @default(cuid())
  cardId      String
  cardConfig  CardConfig @relation(fields: [cardId], references: [cardId], onDelete: Cascade)
  
  component   String   // 'terminal', 'fileSystem', 'monacoEditor', 'tiptapEditor', 'browser'
  roleId      String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([cardId, component])
}

// -----------------------------------------------------------------
// File Ingestion and Vector Storage
// -----------------------------------------------------------------

// Tracks file content hashes to avoid re-indexing unchanged files
model FileIndex {
  filePath    String   @id
  contentHash String
  updatedAt   DateTime @updatedAt
}

// Stores vector embeddings for semantic search
// Note: Using JSON string for vector storage until pgvector extension is enabled
model VectorEmbedding {
  id          String   @id
  vector      String   @db.Text // JSON string representation of the vector
  content     String   @db.Text // The chunk of text this vector represents
  filePath    String
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now())
  
  @@index([filePath])
}

// A generic table to store embeddings linked to any entity (file, job, memory)
model KnowledgeVector {
  id          String   @id @default(cuid())
  
  // What does this vector represent?
  entityType  String   // "file", "memory", "role_description"
  entityId    String   // The ID of the file/memory
  
  // Which model generated this? (Critical for knowing if we can compare them)
  modelId     String
  model       Model    @relation(fields: [modelId], references: [id])
  
  // The actual vector data. 
  // In standard Prisma, we often use Unsupported("vector") 
  // or store as Float[] if using a JS-side vector search initially.
  // For "incomplete data" phase, storing as Float[] is safest/easiest 
  // until you lock in pgvector.
  vector      Float[]  
  
  dimensions  Int      // e.g., 1536
  
  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
}
