datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -----------------------------------------------------------------
// Stores the provider-specific credentials and configuration
// -----------------------------------------------------------------
model Provider {
  id           String @id @default(cuid())
  createdAt    DateTime @default(now())
  
  name         String // e.g., "OpenRouter", "My Local Ollama"
  providerType String // e.g., "openai", "llama", "anthropic"
  baseURL      String @unique
  
  // !!! IMPORTANT: This should be encrypted before saving
  encryptedApiKey String?

  // --- Rate Limiting ---
  requestsPerMinute Int?

  // --- Relations ---
  // A Provider has many Models
  models       Model[]
  // This is the other side of the `provider` relation in `ModelConfig`.
  modelConfigs ModelConfig[]
}

// -----------------------------------------------------------------
// Stores the individual models from all providers
// -----------------------------------------------------------------
model Model {
  id        String @id @default(cuid())
  
  // --- Relation to Provider ---
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // --- Normalized Data (What YOU care about) ---
  modelId      String  // The ID from the provider (e.g., "gpt-4o-mini")
  name         String  // The human-readable name
  isFree       Boolean @default(false)
  rateLimit    String? // (for your enrich agent to fill)

  // --- Fields for the "Role Fiddler" ---
  // These will be populated by your "Enrichment Agent"
  contextWindow  Int?
  hasVision      Boolean @default(false)
  hasReasoning   Boolean @default(false)
  hasCoding      Boolean @default(false)

  // --- The Solution ---
  // Stores the *entire, raw JSON* from the provider's API.
  providerData Json

  // This is the other side of the `model` relation in `ModelConfig`.
  modelConfigs ModelConfig[]

  @@unique([providerId, modelId]) // Prevent duplicate models
}

// -----------------------------------------------------------------
// Stores the Roles for your agents
// -----------------------------------------------------------------
model Role {
  id          String @id @default(cuid())
  name        String @unique
  basePrompt  String @db.Text
  
  // Role Parameters (for the "fiddler")
  minContext  Int?
  maxContext  Int?
  
  // Feature Booleans
  needsVision    Boolean @default(false)
  needsReasoning Boolean @default(false)
  needsCoding    Boolean @default(false)

  // TODO: Add Tool & Task relations later
  preferredModels ModelConfig[] @relation("PreferredModels")

  // This is the other side of the `role` relation in `ModelUsage`.
  modelUsage      ModelUsage[]
}

// -----------------------------------------------------------------
// Stores the configuration for a specific model within a role
// This allows for role-specific overrides or settings for a model
// -----------------------------------------------------------------
model ModelConfig {
  id         String @id @default(cuid())
  createdAt  DateTime @default(now())

  // --- Relation to Model ---
  modelId    String
  model      Model    @relation(fields: [modelId], references: [id])

  // --- Relation to Provider (for convenience/denormalization) ---
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id])

  // --- Role-specific settings for this model ---
  // e.g., max tokens, temperature, etc.
  // These would override global model settings for this specific role
  maxTokens  Int?
  temperature Float?

  // --- Relations ---
  roles      Role[]       @relation("PreferredModels")
  modelUsage ModelUsage[]
}

// -----------------------------------------------------------------
// Stores the usage logs for models
// -----------------------------------------------------------------
model ModelUsage {
  id             String    @id @default(cuid())
  createdAt      DateTime  @default(now())
  userId         String
  modelConfigId  String
  roleId         String
  promptTokens   Int?
  completionTokens Int?
  cost           Float
  metadata       Json?

  // Relations
  modelConfig    ModelConfig @relation(fields: [modelConfigId], references: [id])
  role           Role        @relation(fields: [roleId], references: [id])
}

// -----------------------------------------------------------------
// Raw Data Lake
// Stores raw API responses before they are processed into Models
// -----------------------------------------------------------------
model RawDataLake {
  id         String   @id @default(cuid())
  provider   String   // e.g. "openrouter", "vertex"
  rawData    Json     // The exact JSON returned by the provider's list models endpoint
  ingestedAt DateTime @default(now())
}
