datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -----------------------------------------------------------------
// Stores the provider-specific credentials and configuration
// -----------------------------------------------------------------
model ProviderConfig {
  id          String   @id @default(uuid())
  label       String   // e.g. "My Personal OpenAI", "Team OpenRouter"
  type        String   // e.g. "openai", "anthropic", "generic-openai"
  apiKey      String   // Encrypt this field in the application layer!
  baseURL     String?  // Crucial for generic providers
  isEnabled   Boolean  @default(true)
  requestsPerMinute Int? // Rate limit for this provider
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // --- Relations ---
  models       Model[]
  modelConfigs ModelConfig[]
}

// -----------------------------------------------------------------
// Stores the individual models from all providers
// -----------------------------------------------------------------
model Model {
  id        String @id @default(cuid())
  
  // --- Relation to Provider ---
  providerId String
  provider   ProviderConfig @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // --- Normalized Data (What YOU care about) ---
  modelId      String  // The ID from the provider (e.g., "gpt-4o-mini")
  name         String  // The human-readable name
  isFree       Boolean @default(false)
  limitRequestRate Int?    // Requests allowed per window
  limitWindow      Int?    // Window size in seconds (e.g., 60 for 1 minute)
  costPer1k        Float?  // Cost per 1k tokens (for sorting)

  // --- Fields for the "Role Fiddler" ---
  // These will be populated by your "Enrichment Agent"
  contextWindow  Int?
  hasVision      Boolean @default(false)
  hasReasoning   Boolean @default(false)
  hasCoding      Boolean @default(false)
  
  // NEW: Capabilities & Censorship
  supportedParameters Json? 
  supportsTools       Boolean @default(false) 
  supportsJson        Boolean @default(false)
  isUncensored        Boolean @default(false) // NEW: Derived from is_moderated = false

  // --- The Solution ---
  // Stores the *entire, raw JSON* from the provider's API.
  providerData Json

  // This is the other side of the `model` relation in `ModelConfig`.
  modelConfigs ModelConfig[]

  @@unique([providerId, modelId]) // Prevent duplicate models
}

// -----------------------------------------------------------------
// Stores the Roles for your agents
// -----------------------------------------------------------------
model Role {
  id          String @id @default(cuid())
  name        String @unique
  basePrompt  String @db.Text
  
  // Role Parameters (for the "fiddler")
  minContext  Int?
  maxContext  Int?
  
  // Feature Booleans
  needsVision    Boolean @default(false)
  needsReasoning Boolean @default(false)
  needsCoding    Boolean @default(false)
  
  // NEW: Role requirements
  needsTools     Boolean @default(false)
  needsJson      Boolean @default(false)
  needsUncensored Boolean @default(false)
  needsImageGeneration Boolean @default(false) // NEW: Requirement for image generation // NEW: Requirement for uncensored model

  // Default Hyperparameters (inherited by cards)
  defaultTemperature       Float?   @default(0.7)
  defaultMaxTokens         Int?     @default(2048)
  defaultTopP              Float?   @default(1.0)
  defaultFrequencyPenalty  Float?   @default(0.0)
  defaultPresencePenalty   Float?   @default(0.0)
  defaultStop              Json?    // Array of stop sequences
  defaultSeed              Int?     // For deterministic outputs
  defaultResponseFormat    Json?    // { type: "json_object" } or null

  // Terminal Security
  terminalRestrictions     Json?    // { mode: "whitelist" | "blacklist", commands: string[] }
  
  // Dynamic Registry Criteria (Stores requirements for custom columns)
  criteria                 Json?    // e.g. { "is_fast": true, "iq_score": { "min": 120 } }

  // Tools Configuration
  tools                    String[] @default([]) // Array of tool names (e.g. ["git", "postgres"])

  // TODO: Add Tool & Task relations later
  preferredModels ModelConfig[] @relation("PreferredModels")

  // This is the other side of the `role` relation in `ModelUsage`.
  modelUsage      ModelUsage[]

  // Relation to jobs this role can be assigned to
  jobs        Job[]
}

// -----------------------------------------------------------------
// Stores the configuration for a specific model within a role
// This allows for role-specific overrides or settings for a model
// -----------------------------------------------------------------
model ModelConfig {
  id         String @id @default(cuid())
  createdAt  DateTime @default(now())

  // --- Relation to Model ---
  modelId    String
  model      Model    @relation(fields: [modelId], references: [id])

  // --- Relation to Provider (for convenience/denormalization) ---
  providerId String
  provider   ProviderConfig @relation(fields: [providerId], references: [id])

  // --- Role-specific settings for this model ---
  // e.g., max tokens, temperature, etc.
  // These would override global model settings for this specific role
  maxTokens  Int?
  temperature Float?

  // NEW: Store parameters that were auto-adjusted/ignored 
  adjustedParameters Json?

  // --- Relations ---
  roles      Role[]       @relation("PreferredModels")
  modelUsage ModelUsage[]
}

// -----------------------------------------------------------------
// Stores the usage logs for models
// -----------------------------------------------------------------
model ModelUsage {
  id             String    @id @default(cuid())
  createdAt      DateTime  @default(now())
  userId         String
  modelConfigId  String
  roleId         String
  promptTokens   Int?
  completionTokens Int?
  cost           Float
  metadata       Json?

  // Relations
  modelConfig    ModelConfig @relation(fields: [modelConfigId], references: [id])
  role           Role        @relation(fields: [roleId], references: [id])
}

// -----------------------------------------------------------------
// Raw Data Lake
// Stores raw API responses before they are processed into Models
// -----------------------------------------------------------------
model RawDataLake {
  id         String   @id @default(cuid())
  provider   String   // e.g. "openrouter", "vertex"
  rawData    Json     // The exact JSON returned by the provider's list models endpoint
  ingestedAt DateTime @default(now())
}

model FlattenedTable {
  id          String   @id @default(cuid())
  name        String   @unique // Table name in Postgres
  sourceId    String   // RawDataLake record ID
  columns     Json     // Column definitions {name: string, type: string}[]
  rowCount    Int      @default(0)
  createdAt   DateTime @default(now())
}

// -----------------------------------------------------------------
// Stores how a Raw Table maps to the Unified Model Schema
// Used by the "Merge to C.O.R.E." feature
// -----------------------------------------------------------------
model TableMapping {
  id        String   @id @default(cuid())
  tableName String   @unique // e.g., "openrouterfree"
  
  // Stores the mapping: { "raw_column_name": "Model_field_name" }
  // e.g., { "context_length": "contextWindow", "pricing": "costPer1k" }
  mapping   Json     
  
  updatedAt DateTime @updatedAt
}

model OrchestratorConfig {
  id             String   @id @default("global")
  activeTableName String  @default("unified_models") // The user-selected table
  
  // Future-proofing for strategies
  strategies     Json?    @default("[]") 
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

// Stores reusable SQL queries for data refinement and migration
model SavedQuery {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "OpenRouter Free Models Migration"
  query       String   @db.Text
  targetTable String?  // The table this query targets (e.g., "my_free_models")
  updatedAt   DateTime @updatedAt
}

// Represents a broad scope of work (e.g., a specific repository or project)
model Workspace {
  id        String   @id @default(cuid())
  name      String
  rootPath  String   // Local path on the host machine
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  cards     WorkOrderCard[]
}

// Formerly "Session" or generic "Context" - The persisted state of a user's task
model WorkOrderCard {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  
  // Fencing Configuration
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  relativePath String   @default(".") // Path relative to Workspace root
  
  // Execution Context
  isRemote    Boolean  @default(false)
  sshConfigId String?  // Optional relation to saved SSH configs (if we persist them)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Securely store SSH configs (excluding sensitive secrets if possible, or encrypted)
model SshConfig {
  id        String   @id @default(cuid())
  alias     String   // e.g., "Production Server"
  host      String
  port      Int      @default(22)
  username  String
  // Note: Passwords/Keys should generally be session-based or encrypted via `utils/encryption.ts`
  createdAt DateTime @default(now())
}

// -----------------------------------------------------------------
// Project Management Hierarchy
// -----------------------------------------------------------------

// Top-level container for a complete scope of work.
model Project {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed", "on_hold"
  priority    String   @default("medium") // e.g., "low", "medium", "high", "critical"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relation to its jobs
  jobs        Job[]
}

// A significant phase or step within a project, assigned to a Role.
model Job {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed", "failed"
  priority    String   @default("medium")

  // --- Relations ---
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  roleId      String?  // The role responsible for this job
  role        Role?    @relation(fields: [roleId], references: [id])

  // --- Execution Flow ---
  // For sequential jobs, this points to the job that must be completed first.
  dependsOnJobId String?  @unique
  dependsOn      Job?     @relation("JobDependencies", fields: [dependsOnJobId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  dependencyFor  Job?     @relation("JobDependencies")

  // For parallel jobs, this groups them. They can start once the job they depend on is complete.
  parallelGroup String?

  // --- Timing ---
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relation to its tasks
  tasks       Task[]

  @@index([projectId, status])
  @@index([roleId])
}

// A granular piece of work within a job.
model Task {
  id          String   @id @default(cuid())
  description String   @db.Text
  status      String   @default("not_started") // e.g., "not_started", "in_progress", "completed"

  // --- Relations ---
  jobId       String
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  // --- Timing & Data ---
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  startedAt   DateTime?
  completedAt DateTime?
  completionData Json? // Any data/output generated by the task

  // Relation to its errands
  errands     Errand[]
}

// The most granular action, like a single command or API call.
model Errand {
  id          String   @id @default(cuid())
  description String   @db.Text
  status      String   @default("not_started") // e.g., "not_started", "completed"

  // --- Relations ---
  taskId      String
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // --- Timing ---
  createdAt   DateTime @default(now())
  completedAt DateTime?
}


// -----------------------------------------------------------------
// Orchestration: Defines workflows between roles
// -----------------------------------------------------------------
model Orchestration {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?  @db.Text
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // User ID who created this orchestration
  
  // Steps in this orchestration (ordered)
  steps       OrchestrationStep[]
  
  // Execution history
  executions  OrchestrationExecution[]
  
  // Tags for categorization
  tags        String[] @default([])
  
  // Enable/disable this orchestration
  isActive    Boolean  @default(true)
}

// -----------------------------------------------------------------
// OrchestrationStep: Individual step in an orchestration
// -----------------------------------------------------------------
model OrchestrationStep {
  id              String   @id @default(cuid())
  
  // Relation to parent orchestration
  orchestrationId String
  orchestration   Orchestration @relation(fields: [orchestrationId], references: [id], onDelete: Cascade)
  
  // Step metadata
  name            String   // e.g., "Generate Plan", "Execute Code Review"
  description     String?  @db.Text
  order           Int      // Execution order (0, 1, 2, ...)
  
  // Role assignment
  roleId          String?  // Optional: Pre-assign a specific role
  roleName        String?  // Alternative: Role name for dynamic lookup
  
  // Control flow
  stepType        String   @default("sequential") // "sequential", "parallel", "conditional", "loop"
  
  // Conditional logic (JSON schema)
  condition       Json?    // e.g., { "field": "output.confidence", "operator": ">", "value": 0.8 }
  
  // Input/Output mapping
  inputMapping    Json?    // Maps orchestration context to step input, e.g., { "query": "{{context.userQuery}}" }
  outputMapping   Json?    // Maps step output to orchestration context, e.g., { "plan": "{{output.result}}" }
  
  // Retry configuration
  maxRetries      Int      @default(0)
  retryDelay      Int?     // Delay in milliseconds between retries
  
  // Timeout
  timeout         Int?     // Timeout in milliseconds
  
  // Parallel execution group (for parallel steps)
  parallelGroup   String?  // Steps with same group ID execute in parallel
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([orchestrationId, order])
}

// -----------------------------------------------------------------
// OrchestrationExecution: Tracks execution of orchestrations
// -----------------------------------------------------------------
model OrchestrationExecution {
  id              String   @id @default(cuid())
  
  // Relation to orchestration
  orchestrationId String
  orchestration   Orchestration @relation(fields: [orchestrationId], references: [id], onDelete: Cascade)
  
  // Execution metadata
  status          String   @default("pending") // "pending", "running", "completed", "failed", "cancelled"
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  // Input and output
  input           Json     // Initial input to the orchestration
  output          Json?    // Final output
  context         Json     @default("{}") // Shared context across steps
  
  // Step execution logs
  stepLogs        Json     @default("[]") // Array of { stepId, status, input, output, duration, error }
  
  // Error tracking
  error           String?  @db.Text
  
  // User who triggered this execution
  userId          String?
  
  @@index([orchestrationId, status])
  @@index([startedAt])
}
