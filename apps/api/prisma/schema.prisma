datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -----------------------------------------------------------------
// Stores the provider-specific credentials and configuration
// -----------------------------------------------------------------
model ProviderConfig {
  id          String   @id @default(uuid())
  label       String   // e.g. "My Personal OpenAI", "Team OpenRouter"
  type        String   // e.g. "openai", "anthropic", "generic-openai"
  apiKey      String   // Encrypt this field in the application layer!
  baseURL     String?  // Crucial for generic providers
  isEnabled   Boolean  @default(true)
  requestsPerMinute Int? // Rate limit for this provider
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // --- Relations ---
  models       Model[]
  modelConfigs ModelConfig[]
}

// -----------------------------------------------------------------
// Stores the individual models from all providers
// -----------------------------------------------------------------
model Model {
  id        String @id @default(cuid())
  
  // --- Relation to Provider ---
  providerId String
  provider   ProviderConfig @relation(fields: [providerId], references: [id], onDelete: Cascade)

  // --- Normalized Data (What YOU care about) ---
  modelId      String  // The ID from the provider (e.g., "gpt-4o-mini")
  name         String  // The human-readable name
  isFree       Boolean @default(false)
  rateLimit    String? // (for your enrich agent to fill)

  // --- Fields for the "Role Fiddler" ---
  // These will be populated by your "Enrichment Agent"
  contextWindow  Int?
  hasVision      Boolean @default(false)
  hasReasoning   Boolean @default(false)
  hasCoding      Boolean @default(false)

  // --- The Solution ---
  // Stores the *entire, raw JSON* from the provider's API.
  providerData Json

  // This is the other side of the `model` relation in `ModelConfig`.
  modelConfigs ModelConfig[]

  @@unique([providerId, modelId]) // Prevent duplicate models
}

// -----------------------------------------------------------------
// Stores the Roles for your agents
// -----------------------------------------------------------------
model Role {
  id          String @id @default(cuid())
  name        String @unique
  basePrompt  String @db.Text
  
  // Role Parameters (for the "fiddler")
  minContext  Int?
  maxContext  Int?
  
  // Feature Booleans
  needsVision    Boolean @default(false)
  needsReasoning Boolean @default(false)
  needsCoding    Boolean @default(false)

  // Default Hyperparameters (inherited by cards)
  defaultTemperature       Float?   @default(0.7)
  defaultMaxTokens         Int?     @default(2048)
  defaultTopP              Float?   @default(1.0)
  defaultFrequencyPenalty  Float?   @default(0.0)
  defaultPresencePenalty   Float?   @default(0.0)
  defaultStop              Json?    // Array of stop sequences
  defaultSeed              Int?     // For deterministic outputs
  defaultResponseFormat    Json?    // { type: "json_object" } or null

  // Terminal Security
  terminalRestrictions     Json?    // { mode: "whitelist" | "blacklist", commands: string[] }

  // TODO: Add Tool & Task relations later
  preferredModels ModelConfig[] @relation("PreferredModels")

  // This is the other side of the `role` relation in `ModelUsage`.
  modelUsage      ModelUsage[]
}

// -----------------------------------------------------------------
// Stores the configuration for a specific model within a role
// This allows for role-specific overrides or settings for a model
// -----------------------------------------------------------------
model ModelConfig {
  id         String @id @default(cuid())
  createdAt  DateTime @default(now())

  // --- Relation to Model ---
  modelId    String
  model      Model    @relation(fields: [modelId], references: [id])

  // --- Relation to Provider (for convenience/denormalization) ---
  providerId String
  provider   ProviderConfig @relation(fields: [providerId], references: [id])

  // --- Role-specific settings for this model ---
  // e.g., max tokens, temperature, etc.
  // These would override global model settings for this specific role
  maxTokens  Int?
  temperature Float?

  // --- Relations ---
  roles      Role[]       @relation("PreferredModels")
  modelUsage ModelUsage[]
}

// -----------------------------------------------------------------
// Stores the usage logs for models
// -----------------------------------------------------------------
model ModelUsage {
  id             String    @id @default(cuid())
  createdAt      DateTime  @default(now())
  userId         String
  modelConfigId  String
  roleId         String
  promptTokens   Int?
  completionTokens Int?
  cost           Float
  metadata       Json?

  // Relations
  modelConfig    ModelConfig @relation(fields: [modelConfigId], references: [id])
  role           Role        @relation(fields: [roleId], references: [id])
}

// -----------------------------------------------------------------
// Raw Data Lake
// Stores raw API responses before they are processed into Models
// -----------------------------------------------------------------
model RawDataLake {
  id         String   @id @default(cuid())
  provider   String   // e.g. "openrouter", "vertex"
  rawData    Json     // The exact JSON returned by the provider's list models endpoint
  ingestedAt DateTime @default(now())
}

model FlattenedTable {
  id          String   @id @default(cuid())
  name        String   @unique // Table name in Postgres
  sourceId    String   // RawDataLake record ID
  columns     Json     // Column definitions {name: string, type: string}[]
  rowCount    Int      @default(0)
  createdAt   DateTime @default(now())
}
