# Maintaining Your Monorepo: A Guide to Type Safety and Shared Code

This document explains the best practices for managing and growing your monorepo. The goal is to maintain strict type safety across your entire application and to handle shared code efficiently.

## The Core Concept: A Single Source of Truth

For a multi-agent application, your frontend (`web`) and backend (`api`) must agree on the structure of data, such as what an "Agent" is or what a "Message" looks like. The monorepo allows us to define these structures (TypeScript interfaces) in **one single place**. This shared package becomes the "single source of truth." If you change a type, your code editor and the TypeScript compiler will immediately tell you everywhere that needs to be updated in both the frontend and backend, preventing bugs before they happen.

---

## Scenario 1: Bringing in Your Own Shared Utilities

This is the most common and powerful use case for the `packages` directory. Let's say you want to create a shared utility function.

**1. Create the new package:**

First, create a directory for your new package. We'll call it `utils`.

```bash
# From the root of your project (/home/guy/mono)
mkdir -p packages/utils/src
```

**2. Define the package:**

Create a `package.json` file inside `packages/utils`. This gives it a name so other apps can reference it.

```json
// packages/utils/package.json
{
  "name": "@repo/utils",
  "version": "1.0.0",
  "main": "src/index.ts",
  "private": true
}
```

**3. Add your shared code:**

Create your utility function inside `packages/utils/src/index.ts`.

```typescript
// packages/utils/src/index.ts
export function formatTimestamp(timestamp: number): string {
  return new Date(timestamp).toLocaleTimeString();
}
```

**4. Use the shared package:**

Now, add this new utility package to the apps that need it.

```bash
# From the root of your project (/home/guy/mono)
pnpm add @repo/utils --filter api
pnpm add @repo/utils --filter web
```

You can now import and use `formatTimestamp` in both your frontend and backend, and it will always be the exact same function.

---

## Scenario 2: Downloading an External SDK (The Right Way)

This is what caused our earlier confusion. An external SDK from npm (like the real `volcano-sdk`, `axios`, or `react`) does **not** go in the `packages` directory. The `packages` directory is only for *your own code* that you are writing as part of this monorepo.

To download and use an external SDK, you install it directly into the application that needs it using `pnpm add`.

**Example: Installing `volcano-sdk` into your `api` app.**

1.  **Run the install command:**

    ```bash
    # From the root of your project (/home/guy/mono)
    pnpm add volcano-sdk --filter api
    ```

2.  **How it works:**
    This command downloads `volcano-sdk` from the npm registry and adds it as a dependency inside `apps/api/package.json`. It will be located in the `node_modules` folder, managed entirely by `pnpm`.

3.  **Use it:**
    You can now import it directly in your backend code.

    ```typescript
    // apps/api/src/index.ts
    import { Volcano } from 'volcano-sdk';
    // ... your code to use the Volcano framework
    ```

---

## Scenario 3: Pulling Code from GitHub

If you have a utility or package that lives in its own Git repository, you can bring it into your monorepo without manually copying files. The best way to do this with `pnpm` is to add it directly as a Git dependency.

**Example: Adding a utility library from GitHub to your `api` app.**

1.  **Run the `pnpm add` command with the Git URL:**

    ```bash
    # From the root of your project (/home/guy/mono)
    pnpm add "github:user/repo" --filter api
    ```
    *(Replace `"github:user/repo"` with the actual repository URL, e.g., `"github:lodash/lodash"`)*

2.  **How it works:**
    `pnpm` will fetch the repository and install it just like a regular npm package. You can even specify a branch or commit hash (`"github:user/repo#branch-name"`). This is much cleaner than using Git Submodules, as it's managed entirely within your `package.json` and `pnpm-lock.yaml` file.

By following these patterns, you can keep your monorepo clean, maintainable, and fully type-safe.

```

This guide should serve as a clear reference for you moving forward. It directly addresses the scenarios you mentioned and clarifies the crucial difference between your own internal packages and external, downloadable ones.

<!--
[PROMPT_SUGGESTION]Using this guide, show me the exact steps to create a shared `types` package for my AI agents.[/PROMPT_SUGGESTION]
[PROMPT_SUGGESTION]Let's install the `volcano-sdk` into the `api` app now. What's the command?[/PROMPT_SUGGESTION]
